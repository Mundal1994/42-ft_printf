approach of creating printf


we can use stdarg.h
	takes in arguemnts of varying types

printf - are we allowed to add restrict to prototype

- writes to standard output
- write output unter the control of format string that specifies how subsequent arguments (stdarg(3)) are converted for output
- format string is composed of zero or more directives: 
	- ordinary chars (not %) are copied unchanged to output
	- each conversion specification is introduced by % char
		- argument must match with the conversion specifier which appear after % (ex %d)
	- return value: return number of characters printed (not incl the trailing '\0' used to end output to string)

- does not handle multibyte characters in the format argument
- don't know if this is something we have to recreate: %n used to write arbitrary data to porentially ccarefully-selected addresses. don't pass untrusted strings as the format arg because attacker can put format secifiers in the string to mangle your stack leading to security hole. can happen with other printf versions as well. %n is assumed to be untrustworthy if located in writable memory. practically, this means that %n is permitted in literal format stirngs but disallowed in format strings located in normal stack- or heap- allocated memory.

ALLOWED FUNCTIONS
- write
- malloc
- free
- exit
- functions of man 3 stdarg

mandatory part
HAVE TO MANAGE FOLLOWING CONVERSIONS (conversion specifies whether to interpret the corresponding argument as a charater, a string, a pointer, an integer or a floating-point number)
- csp
	- value should be converted to an alternate form if # is used. csp conversions doesnt have any effect.
	- is p the void* pointer argument in hexidecimal??
- diouxX (with the flags: hh, h, l and ll)
	- if a precision has been given about the minimum digits that must appear but the converted value requires fewer digits it has to be padded on the left with zeros.
	printf(%-+5.d", 133);
	output: +133

	printf(%-+5.6", 133);
	output: +000133

	length modifier that specifies the size of the argument. these length modifiers are valid for d, i, n, o, u, x and X conversion:
	modifier	d, i			o, u, x, X		n
	hh				signed char		unsigned char	signed char *
	h				short			unsigned short	short *
	l (ell)			long			unsigned long	long *
	ll (ell ell)	long long		unsigned long long	long long*
- f (with the flags: l and L)
	- (i think it is this at least): a blank should be left before a positive number produced by a signed conversion (f)
	- or... # value should be converted to alternate form. f - result will always contain a decimal point, even if no digits follow it.

	length modifier
	modifier	f
	l (ell)		double (ignored, same behaviour as without it)
	L			long double


YOU MUST MANAGE
- %%
- #0-+ and space
- minimum field-width
	- width of field will be the minimum required to hold the data.
- precision
	- if you want to specify the precision of an argument it MUST be prefixed with the period.
	- precision is different depending on the format type
		- float precision
			%8.2f << this means that you require a total field of 8 characters, within the 8 characters the last 2 will hold the decimal part
			%0.2 << request minimum field width and the last two characters are to hold the decimal part.
		- character string maximum field width
			precision withing a string format specifies the maximum field width
				%4.8s << specifies minimum width of 4 and a maximum width of 8 characters. If the string is greater than 8 characters, it will be cropped down to size.


STDARG
#include <stdarg.h>
- va_start: initializes arg_ptr for subsequent calls to va_arg() and va_end()
- va_arg: retrieves a value of the given var_type from the location given by arg_ptr and increases arg_ptr to point to the next argument in the list. va_arg can retrieve arguments from the list any number of times withtin the function. returns current argument
- va_copy: creates copy (dest) of variable of type va_list (src). The copy appear as if it has gone through a va_start() and the exact set of sequences of va_arg() as that of src. when dest has been initialized the va_copy macro shouldn't be invoked to reinitialize dest without using va_end first for the same dest.
- va_end: va_start and va_end must be in same function. va_end is needed by some systems to indicate end of parameter scanning.
va_start, va_copy and ca_end

- va_list: is the object type that holds information needed byt he macros va_start, va_copy, va_arg and va_end
	char *va_list[2]


FORMAT IDENTIFIERS
- %d %i	decimal signed integer
- %o	octal integer
- %x %X	hex integer
- %u	unsigned integer
- %c	character
- %s	string
- %f	double
- %e %E	double
- %g %G	double
- %p	pointer
- %n	number of characters written by this printf
- %%	%. No argument expected


FLAGS
Format identifiers can be altered from their default function by applying the following flags:
- -	left justify.
- 0	field is padded with 0's instead of blanks.
- +	sign of number always O/P.
- blank	positive values begin with a blank.
- #	various uses:
	%#o	(octal) 0 prefix inserted.
	%#x	(hex)	0x prefix added to non-zero values.
	%#X	(hex)	0X prefix added to non-zero values.
	%#e			always show the decimal point.
	%#E			always show the decimal point.
	%#f			always show the decimal point.
	%#g			always show the decimal point trailing zeros not removed.
	%#G			always show the decimal point trailing zeros not removed.
examples
	printf(" %-10d \n", number);
	printf(" %010d \n", number);
	printf(" %-#10x \n", number);
	printf(" %#x \n", number);


TODO:
- test and play around with printf to see how it acts with the different characters

links:
- https://www.ibm.com/docs/en/zos/2.3.0?topic=lf-va-arg-va-copy-va-end-va-start-access-function-arguments
- https://www.lix.polytechnique.fr/~liberti/public/computing/prog/c/C/FUNCTIONS/format.html
- 
-------


#
this has no effect on c, d, i, n, p, s and u
affects x, X, o and f

0
zero padding.
padded on the left with zeros. if precision is given the 0 flag is ignored

-
negative field width flag - value is left adjusted on the field boundary. - overrides 0 if both are given

' '
blank before postive number produced by signed conversion d, f, i

+
sig must always be placed before a number produced by a signed conversion. + overrides space if both are used



ask jeff - undefined behaviour ex using # with s - return error / quit program or print result anyway?


-------

loop through string
	if not %
		ft_putchar character
	else
		if next char is %
			ft_putchar %
			move curser one extra
		else
			call function that will check the next characters (returns nbr to know how many char we have put) (figure out what numbers exactly does)
			need to move curser until end (so check for csp, diouxX and f ?)
	go to next char



STDARG
#include <stdarg.h>
- va_start: initializes arg_ptr for subsequent calls to va_arg() and va_end()
- va_arg: retrieves a value of the given var_type from the location given by arg_ptr and increases arg_ptr to point to the next argument in the list. va_arg can retrieve arguments from the list any number of times withtin the function. returns current argument
- va_copy: creates copy (dest) of variable of type va_list (src). The copy appear as if it has gone through a va_start() and the exact set of sequences of va_arg() as that of src. when dest has been initialized the va_copy macro shouldn't be invoked to reinitialize dest without using va_end first for the same dest.
- va_end: va_start and va_end must be in same function. va_end is needed by some systems to indicate end of parameter scanning.
va_start, va_copy and ca_end

- va_list: is the object type that holds information needed byt he macros va_start, va_copy, va_arg and va_end
	char *va_list[2]



function to check the next char
	maybe first find the flags (typedef enum useful?)
	i think i should use va_start, va_arg, va_end etc...
	va_start
	if (char == csp, diouxX, f)
		add to enum
		flag function - simple print ( add something to skip some calculations ex TRUE or FALSE)
		return (nbr);
	while we havent reached csp, diouxX and f keep looping
		if (char == csp, diouxX, f)
			add to enum
			break ;
		if (char == # || char == 0 && char + 1 != ft_digit || char == - || char == + || char == space || precision)
			call a function that adds what 0 does or check if next is a number to do minimum-field width
		else if (char == h && char + 1 != h || char == l && char + 1 != ll || char == L)
			call a function to check this
		else if (char == h && char + 1 == h || char == l && char + 1 == ll)
			call a function to check this
		else if (min field-width (char == 0 && char + 1 == ft_digit), precision)
			call a    unction to check this
	flag function check print
	return (nbr)



flag function check print
	while loop through enum
	if (csp)
		call function for csp (TRUE FALSE)
	else if (diouxX)
		call function for diouxX (TRUE FALSE)
	else
		call function for f (TRUE FALSE)


function csp
	loop through to check if other flags has been checked (if TRUE FALSE)
	if (true or false)
		if (#0-+, width precision)
			call function for that (think it will be the same for all the cases)
	print (diouxX)


function diouxX
	loop through to check if other flags has been checked (if TRUE FALSE)
	if (true or false)
		if (#0-+, width precision)
			call function for that (think it will be the same for all the cases)
		else if (function for flags ll, l, hh, h
			call function for that
	print (diouxX)


function f
	loop through to check if other flags has been checked (if TRUE FALSE)
	if (true or false)
		if (#0-+, width precision)
			call function for that (think it will be the same for all the cases)
		else if (function for flags l, L
			call function for that
	print (diouxX)


function for flags #0+- etc
	if (#)
		do
	if (-)
		do


function for flags ll, l, hh, h
	if (h)
		do
	if (l)
		do


function for l and L (h)
	if (l)
		do
	if (L)
		do
